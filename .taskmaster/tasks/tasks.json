{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Integrate Stripe Payment Solution with Team Limit Subscription Tiers",
        "description": "Implement a subscription-based payment system using Stripe to restrict team creation based on membership tiers: Free (1 team), Standard (3 teams), and Pro (10 teams).",
        "details": "## Implementation Overview\n\nThis task integrates Stripe subscription management into the VolleyStats application to enforce team creation limits based on user subscription tiers.\n\n## Database Schema Changes\n\n### 1. Create new `subscriptions` table\n```sql\n-- supabase/migrations/YYYYMMDD_add_subscriptions.sql\nCREATE TYPE public.subscription_tier AS ENUM ('free', 'standard', 'pro');\nCREATE TYPE public.subscription_status AS ENUM ('active', 'canceled', 'past_due', 'incomplete');\n\nCREATE TABLE public.subscriptions (\n  id uuid DEFAULT gen_random_uuid() PRIMARY KEY,\n  user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE NOT NULL UNIQUE,\n  tier public.subscription_tier NOT NULL DEFAULT 'free',\n  status public.subscription_status NOT NULL DEFAULT 'active',\n  stripe_customer_id text UNIQUE,\n  stripe_subscription_id text UNIQUE,\n  stripe_price_id text,\n  team_limit integer NOT NULL DEFAULT 1,\n  current_period_start timestamp with time zone,\n  current_period_end timestamp with time zone,\n  cancel_at_period_end boolean DEFAULT false,\n  created_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL,\n  updated_at timestamp with time zone DEFAULT timezone('utc'::text, now()) NOT NULL\n);\n\n-- Add RLS policies\nALTER TABLE public.subscriptions ENABLE ROW LEVEL SECURITY;\n\nCREATE POLICY \"Users can view their own subscription\"\n  ON public.subscriptions FOR SELECT\n  USING (auth.uid() = user_id);\n\n-- Only service role can insert/update (via Stripe webhooks)\nCREATE POLICY \"Service role can manage subscriptions\"\n  ON public.subscriptions FOR ALL\n  USING (auth.role() = 'service_role');\n\n-- Create index for faster lookups\nCREATE INDEX idx_subscriptions_user_id ON public.subscriptions(user_id);\nCREATE INDEX idx_subscriptions_stripe_customer_id ON public.subscriptions(stripe_customer_id);\n```\n\n### 2. Add subscription reference to profiles\n```sql\nALTER TABLE public.profiles\n  ADD COLUMN subscription_id uuid REFERENCES public.subscriptions(id) ON DELETE SET NULL;\n\nCREATE INDEX idx_profiles_subscription_id ON public.profiles(subscription_id);\n```\n\n### 3. Create function to check team creation limit\n```sql\nCREATE OR REPLACE FUNCTION check_team_creation_limit()\nRETURNS TRIGGER AS $$\nDECLARE\n  user_subscription RECORD;\n  current_team_count INTEGER;\nBEGIN\n  -- Get user's subscription info\n  SELECT s.tier, s.team_limit, s.status\n  INTO user_subscription\n  FROM public.subscriptions s\n  WHERE s.user_id = NEW.user_id;\n\n  -- Default to free tier if no subscription exists\n  IF NOT FOUND THEN\n    user_subscription.team_limit := 1;\n    user_subscription.status := 'active';\n  END IF;\n\n  -- Only enforce limits for active subscriptions\n  IF user_subscription.status != 'active' THEN\n    RAISE EXCEPTION 'Subscription is not active. Please update your payment method.';\n  END IF;\n\n  -- Count existing teams for this user\n  SELECT COUNT(*)\n  INTO current_team_count\n  FROM public.teams\n  WHERE user_id = NEW.user_id;\n\n  -- Check if limit would be exceeded\n  IF current_team_count >= user_subscription.team_limit THEN\n    RAISE EXCEPTION 'Team creation limit reached. Upgrade your subscription to create more teams. Current limit: %', user_subscription.team_limit;\n  END IF;\n\n  RETURN NEW;\nEND;\n$$ LANGUAGE plpgsql SECURITY DEFINER;\n\n-- Add trigger to teams table\nCREATE TRIGGER enforce_team_creation_limit\n  BEFORE INSERT ON public.teams\n  FOR EACH ROW\n  EXECUTE FUNCTION check_team_creation_limit();\n```\n\n## TypeScript Type Definitions\n\nUpdate `lib/types.ts`:\n\n```typescript\nexport type SubscriptionTier = 'free' | 'standard' | 'pro';\nexport type SubscriptionStatus = 'active' | 'canceled' | 'past_due' | 'incomplete';\n\nexport type Subscription = {\n  id: string;\n  user_id: string;\n  tier: SubscriptionTier;\n  status: SubscriptionStatus;\n  stripe_customer_id: string | null;\n  stripe_subscription_id: string | null;\n  stripe_price_id: string | null;\n  team_limit: number;\n  current_period_start: string | null;\n  current_period_end: string | null;\n  cancel_at_period_end: boolean;\n} & Partial<Audited>;\n\nexport type Profile = {\n  // ... existing fields\n  subscription_id: string | null;\n  subscription?: Subscription | null;\n};\n\nexport const SUBSCRIPTION_TIERS = {\n  free: { name: 'Free', teamLimit: 1, price: 0 },\n  standard: { name: 'Standard', teamLimit: 3, price: 9.99 },\n  pro: { name: 'Pro', teamLimit: 10, price: 19.99 }\n} as const;\n```\n\n## Stripe Integration\n\n### 1. Install Stripe SDK\n```bash\npnpm add stripe @stripe/stripe-js\n```\n\n### 2. Environment Variables\nAdd to `.env.local`:\n```\nNEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_...\nSTRIPE_SECRET_KEY=sk_test_...\nSTRIPE_WEBHOOK_SECRET=whsec_...\n```\n\n### 3. Create Stripe API wrapper\n`lib/stripe/client.ts`:\n```typescript\nimport Stripe from 'stripe';\n\nexport const stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n  apiVersion: '2024-11-20.acacia',\n  typescript: true,\n});\n```\n\n### 4. Server-side API routes\n\n`app/api/stripe/checkout/route.ts`:\n```typescript\nimport { NextRequest, NextResponse } from 'next/server';\nimport { stripe } from '@/lib/stripe/client';\nimport { createServerClient } from '@/lib/supabase/server';\n\nexport async function POST(request: NextRequest) {\n  try {\n    const { tier } = await request.json();\n    const supabase = createServerClient();\n    \n    const { data: { user }, error } = await supabase.auth.getUser();\n    if (error || !user) {\n      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });\n    }\n\n    // Get or create Stripe customer\n    const { data: subscription } = await supabase\n      .from('subscriptions')\n      .select('stripe_customer_id')\n      .eq('user_id', user.id)\n      .single();\n\n    let customerId = subscription?.stripe_customer_id;\n\n    if (!customerId) {\n      const customer = await stripe.customers.create({\n        email: user.email,\n        metadata: { supabase_user_id: user.id }\n      });\n      customerId = customer.id;\n    }\n\n    // Price IDs (create these in Stripe Dashboard first)\n    const priceIds = {\n      standard: process.env.STRIPE_STANDARD_PRICE_ID!,\n      pro: process.env.STRIPE_PRO_PRICE_ID!\n    };\n\n    const session = await stripe.checkout.sessions.create({\n      customer: customerId,\n      line_items: [{ price: priceIds[tier as 'standard' | 'pro'], quantity: 1 }],\n      mode: 'subscription',\n      success_url: `${process.env.NEXT_PUBLIC_APP_URL}/settings?subscription=success`,\n      cancel_url: `${process.env.NEXT_PUBLIC_APP_URL}/settings?subscription=canceled`,\n      metadata: { supabase_user_id: user.id, tier }\n    });\n\n    return NextResponse.json({ sessionId: session.id, url: session.url });\n  } catch (error) {\n    console.error('Checkout error:', error);\n    return NextResponse.json({ error: 'Failed to create checkout session' }, { status: 500 });\n  }\n}\n```\n\n`app/api/stripe/webhook/route.ts`:\n```typescript\nimport { NextRequest, NextResponse } from 'next/server';\nimport { stripe } from '@/lib/stripe/client';\nimport { supabase } from '@/lib/supabase/client';\nimport Stripe from 'stripe';\n\nconst TEAM_LIMITS = { free: 1, standard: 3, pro: 10 };\n\nexport async function POST(request: NextRequest) {\n  const body = await request.text();\n  const sig = request.headers.get('stripe-signature')!;\n\n  let event: Stripe.Event;\n\n  try {\n    event = stripe.webhooks.constructEvent(body, sig, process.env.STRIPE_WEBHOOK_SECRET!);\n  } catch (err) {\n    return NextResponse.json({ error: 'Webhook signature verification failed' }, { status: 400 });\n  }\n\n  // Handle the event\n  switch (event.type) {\n    case 'checkout.session.completed': {\n      const session = event.data.object as Stripe.Checkout.Session;\n      const userId = session.metadata?.supabase_user_id;\n      const tier = session.metadata?.tier as 'standard' | 'pro';\n\n      if (userId && tier) {\n        await supabase.from('subscriptions').upsert({\n          user_id: userId,\n          tier,\n          status: 'active',\n          stripe_customer_id: session.customer as string,\n          stripe_subscription_id: session.subscription as string,\n          team_limit: TEAM_LIMITS[tier],\n          current_period_start: new Date().toISOString(),\n          current_period_end: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000).toISOString()\n        });\n      }\n      break;\n    }\n\n    case 'customer.subscription.updated': {\n      const subscription = event.data.object as Stripe.Subscription;\n      const customerId = subscription.customer as string;\n\n      const { data: existingSub } = await supabase\n        .from('subscriptions')\n        .select('user_id')\n        .eq('stripe_customer_id', customerId)\n        .single();\n\n      if (existingSub) {\n        await supabase.from('subscriptions').update({\n          status: subscription.status as any,\n          current_period_start: new Date(subscription.current_period_start * 1000).toISOString(),\n          current_period_end: new Date(subscription.current_period_end * 1000).toISOString(),\n          cancel_at_period_end: subscription.cancel_at_period_end\n        }).eq('user_id', existingSub.user_id);\n      }\n      break;\n    }\n\n    case 'customer.subscription.deleted': {\n      const subscription = event.data.object as Stripe.Subscription;\n      await supabase.from('subscriptions').update({\n        status: 'canceled',\n        tier: 'free',\n        team_limit: 1\n      }).eq('stripe_subscription_id', subscription.id);\n      break;\n    }\n  }\n\n  return NextResponse.json({ received: true });\n}\n```\n\n### 5. Create subscription API layer\n`lib/api/subscriptions/index.ts`:\n```typescript\nimport { Subscription } from '@/lib/types';\nimport { SupabaseDataStore } from '../supabase';\nimport { SupabaseClient } from '@supabase/supabase-js';\n\nexport const createSubscriptionApi = (supabaseClient?: SupabaseClient) => {\n  const dataStore = new SupabaseDataStore('subscriptions', supabaseClient);\n\n  return {\n    getSubscription: async (userId: string): Promise<Subscription | null> => {\n      const { data, error } = await dataStore.client\n        .from('subscriptions')\n        .select('*')\n        .eq('user_id', userId)\n        .maybeSingle();\n\n      if (error) throw error;\n      return data as Subscription | null;\n    },\n\n    checkTeamLimit: async (userId: string): Promise<{ canCreate: boolean; current: number; limit: number }> => {\n      const subscription = await this.getSubscription(userId);\n      const limit = subscription?.team_limit || 1;\n\n      const { count } = await dataStore.client\n        .from('teams')\n        .select('*', { count: 'exact', head: true })\n        .eq('user_id', userId);\n\n      return {\n        canCreate: (count || 0) < limit,\n        current: count || 0,\n        limit\n      };\n    }\n  };\n};\n```\n\n## UI Components\n\n### 1. Subscription upgrade modal\n`components/settings/subscription-upgrade-dialog.tsx`:\n```typescript\n'use client';\n\nimport { useState } from 'react';\nimport { loadStripe } from '@stripe/stripe-js';\nimport { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';\nimport { Button } from '@/components/ui/button';\nimport { Check } from 'lucide-react';\nimport { SUBSCRIPTION_TIERS } from '@/lib/types';\n\nconst stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!);\n\nexport function SubscriptionUpgradeDialog({ open, onOpenChange }: { open: boolean; onOpenChange: (open: boolean) => void }) {\n  const [loading, setLoading] = useState<string | null>(null);\n\n  const handleUpgrade = async (tier: 'standard' | 'pro') => {\n    setLoading(tier);\n    try {\n      const response = await fetch('/api/stripe/checkout', {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ tier })\n      });\n\n      const { url } = await response.json();\n      window.location.href = url;\n    } catch (error) {\n      console.error('Checkout error:', error);\n    } finally {\n      setLoading(null);\n    }\n  };\n\n  return (\n    <Dialog open={open} onOpenChange={onOpenChange}>\n      <DialogContent className=\"max-w-4xl\">\n        <DialogHeader>\n          <DialogTitle>Upgrade Your Subscription</DialogTitle>\n        </DialogHeader>\n        <div className=\"grid grid-cols-3 gap-4\">\n          {Object.entries(SUBSCRIPTION_TIERS).map(([key, tier]) => (\n            <div key={key} className=\"border rounded-lg p-6\">\n              <h3 className=\"text-xl font-bold\">{tier.name}</h3>\n              <p className=\"text-3xl font-bold mt-4\">${tier.price}<span className=\"text-sm\">/mo</span></p>\n              <ul className=\"mt-4 space-y-2\">\n                <li className=\"flex items-center gap-2\">\n                  <Check className=\"w-4 h-4\" />\n                  <span>{tier.teamLimit} team{tier.teamLimit > 1 ? 's' : ''}</span>\n                </li>\n                <li className=\"flex items-center gap-2\">\n                  <Check className=\"w-4 h-4\" />\n                  <span>Unlimited matches</span>\n                </li>\n                <li className=\"flex items-center gap-2\">\n                  <Check className=\"w-4 h-4\" />\n                  <span>Offline support</span>\n                </li>\n              </ul>\n              {key !== 'free' && (\n                <Button\n                  className=\"w-full mt-6\"\n                  onClick={() => handleUpgrade(key as 'standard' | 'pro')}\n                  disabled={loading === key}\n                >\n                  {loading === key ? 'Loading...' : 'Upgrade'}\n                </Button>\n              )}\n            </div>\n          ))}\n        </div>\n      </DialogContent>\n    </Dialog>\n  );\n}\n```\n\n### 2. Update team creation flow\nIn `components/teams/team-form.tsx`, add subscription check:\n```typescript\nconst { checkTeamLimit } = useSubscriptionApi();\n\nconst handleSubmit = async (data: TeamFormData) => {\n  const limitCheck = await checkTeamLimit(user.id);\n  \n  if (!limitCheck.canCreate) {\n    toast.error(`Team limit reached (${limitCheck.current}/${limitCheck.limit}). Please upgrade your subscription.`);\n    setShowUpgradeDialog(true);\n    return;\n  }\n\n  // Proceed with team creation...\n};\n```\n\n## Testing Strategy\n\nTest the following scenarios:\n\n1. **Database Level**:\n   - Create trigger works: Attempt to create more teams than allowed â†’ Should fail with proper error message\n   - Subscription tier changes update team_limit correctly\n   - RLS policies prevent unauthorized access to subscription data\n\n2. **Stripe Integration**:\n   - Checkout session creation for Standard and Pro tiers\n   - Webhook handling for `checkout.session.completed`, `customer.subscription.updated`, `customer.subscription.deleted`\n   - Customer creation and linking to Supabase user_id\n   - Test with Stripe CLI: `stripe listen --forward-to localhost:3000/api/stripe/webhook`\n\n3. **UI/UX**:\n   - Team creation blocked with upgrade prompt when limit reached\n   - Subscription upgrade dialog displays correct tier information\n   - Successful subscription redirects to settings page with success message\n   - Canceled checkout redirects with canceled message\n\n4. **Edge Cases**:\n   - User with no subscription defaults to free tier (1 team)\n   - Downgrading subscription when user has more teams than new limit (graceful handling)\n   - Payment failures and retry logic\n   - Subscription cancellation retains access until period end\n\n## RxDB Sync Considerations\n\nAdd `subscriptions` collection to RxDB schema in `lib/rxdb/schema/subscriptions.ts` following existing patterns. Ensure offline team creation checks cached subscription data before attempting sync.",
        "testStrategy": "1. **Database Testing**: Run migration and verify trigger with SQL: `INSERT INTO teams (name, user_id) VALUES ('Test Team', 'user_id')` after creating 1/3/10 teams for each tier. Verify error messages.\n\n2. **Stripe Webhook Testing**: Use Stripe CLI to simulate events: `stripe trigger checkout.session.completed`, `stripe trigger customer.subscription.updated`, `stripe trigger customer.subscription.deleted`. Verify database updates.\n\n3. **Integration Testing**: Create test accounts and complete full checkout flows for Standard and Pro tiers. Verify team creation limits are enforced immediately after subscription activation.\n\n4. **UI Testing**: Test subscription upgrade dialog appearance when team limit is reached. Verify redirect flows (success/cancel). Test responsive design on mobile devices.\n\n5. **Downgrade Scenario**: Subscribe to Pro (10 teams), create 10 teams, downgrade to Standard (3 teams). Verify existing teams remain accessible but new team creation is blocked with appropriate messaging.\n\n6. **Offline Testing**: Disconnect from internet, attempt to create team at limit. Verify proper error handling and sync queue behavior when connection is restored.\n\n7. **Load Testing**: Simulate multiple concurrent webhook events to ensure database transactions handle race conditions properly.",
        "status": "pending",
        "dependencies": [],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Create database schema for subscriptions with RLS policies and team creation trigger",
            "description": "Create a new Supabase migration file that adds the subscriptions table, enum types, RLS policies, and a database trigger to enforce team creation limits based on subscription tiers.",
            "dependencies": [],
            "details": "Create file `supabase/migrations/YYYYMMDD_add_subscriptions_and_team_limits.sql` with: 1) Enum types `subscription_tier` (free, standard, pro) and `subscription_status` (active, canceled, past_due, incomplete). 2) `subscriptions` table with fields: id, user_id (FK to auth.users), tier (default 'free'), status, stripe_customer_id, stripe_subscription_id, stripe_price_id, team_limit (default 1), current_period_start, current_period_end, cancel_at_period_end, created_at, updated_at. 3) RLS policies: users can SELECT their own subscription, only service_role can INSERT/UPDATE. 4) Create indexes on user_id and stripe_customer_id. 5) Add subscription_id column to profiles table. 6) Create PL/pgSQL function `check_team_creation_limit()` that queries user's subscription, defaults to free tier (1 team) if none exists, counts existing teams from teams table, and raises exception if limit exceeded. 7) Add BEFORE INSERT trigger on teams table to call this function. Follow pattern from existing migration files in supabase/migrations/.",
            "status": "pending",
            "testStrategy": "Test by running migration locally with `supabase db reset`. Verify trigger works by attempting to insert teams beyond limit using SQL: INSERT INTO teams (name, user_id) VALUES ('Test Team', 'user_id') multiple times. Should succeed for first team (free tier default), fail with proper error message on second team. Test with different tier values and verify correct limits (1/3/10)."
          },
          {
            "id": 2,
            "title": "Install Stripe SDK and create server-side Stripe API wrapper with environment configuration",
            "description": "Add Stripe dependencies to the project, configure environment variables for Stripe API keys, and create a server-side Stripe client wrapper following the existing lib/ structure.",
            "dependencies": [
              1
            ],
            "details": "1) Run `pnpm add stripe @stripe/stripe-js` to install Stripe SDK and React bindings. 2) Add to `.env.example` and `.env.local`: NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY, STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, STRIPE_STANDARD_PRICE_ID, STRIPE_PRO_PRICE_ID, NEXT_PUBLIC_APP_URL. 3) Create `lib/stripe/client.ts` exporting a configured Stripe instance using `new Stripe(process.env.STRIPE_SECRET_KEY!, { apiVersion: '2024-11-20.acacia', typescript: true })`. 4) Update `lib/types.ts` to add: SubscriptionTier type ('free' | 'standard' | 'pro'), SubscriptionStatus type, Subscription type matching database schema, SUBSCRIPTION_TIERS constant object with tier details (name, teamLimit, price). 5) Update Profile type to include optional subscription_id and subscription fields.",
            "status": "pending",
            "testStrategy": "Verify installation by checking package.json for stripe packages. Test Stripe client instantiation by creating a simple test file that imports the client and logs stripe.customers (should not throw errors). Verify TypeScript types compile without errors by running `npm run build`. Check that environment variables are properly typed by attempting to use them in a test script."
          },
          {
            "id": 3,
            "title": "Create Stripe checkout session and webhook API routes for subscription management",
            "description": "Implement Next.js API routes for creating Stripe checkout sessions and handling Stripe webhook events to manage subscription lifecycle (creation, updates, cancellations).",
            "dependencies": [
              2
            ],
            "details": "1) Create `app/api/stripe/checkout/route.ts` with POST handler that: authenticates user via `createServerClient()` from lib/supabase/server, retrieves or creates Stripe customer using user email and metadata, creates checkout session with tier-based price ID, returns session URL. 2) Create `app/api/stripe/webhook/route.ts` with POST handler that: verifies webhook signature using stripe.webhooks.constructEvent(), handles 'checkout.session.completed' event to upsert subscription record with tier/status/customer_id/subscription_id, handles 'customer.subscription.updated' to update period dates and status, handles 'customer.subscription.deleted' to downgrade to free tier. Use TEAM_LIMITS constant {free: 1, standard: 3, pro: 10}. Both routes should use SupabaseClient with service role for database writes since they run server-side. Follow pattern from existing API route in app/api/import/ffvb/route.ts.",
            "status": "pending",
            "testStrategy": "Test checkout route: Use Postman or curl to POST to /api/stripe/checkout with body {tier: 'standard'}, verify returns sessionId and url. Test webhook route locally using Stripe CLI: `stripe listen --forward-to localhost:3000/api/stripe/webhook`, then trigger test events `stripe trigger checkout.session.completed`, verify subscription record created in Supabase. Test subscription.updated and subscription.deleted events similarly. Check database after each webhook to verify correct data inserted/updated."
          },
          {
            "id": 4,
            "title": "Create subscription API layer and React hooks following repository pattern",
            "description": "Build the subscription data access layer using the existing SupabaseDataStore pattern and create React hooks for subscription operations, following patterns from lib/api/teams/ and hooks/use-team-api.ts.",
            "dependencies": [
              2
            ],
            "details": "1) Create `lib/api/subscriptions/index.ts` exporting `createSubscriptionApi(supabaseClient?)` function that returns: `getSubscription(userId)` - fetches single subscription by user_id using SupabaseDataStore, `checkTeamLimit(userId)` - gets subscription and counts user's teams, returns {canCreate: boolean, current: number, limit: number}. Use SupabaseDataStore('subscriptions', supabaseClient) for database access. 2) Create `hooks/use-subscription-api.ts` that calls createSubscriptionApi with client from createClient(). 3) Export subscription API from lib/api/index.ts. Follow exact pattern from lib/api/teams/index.ts (lines 6-24) and ensure TypeScript types align with Database types from lib/supabase/database.types.ts.",
            "status": "pending",
            "testStrategy": "Create a test page that imports useSubscriptionApi and calls getSubscription/checkTeamLimit with current user ID. Verify API returns correct subscription data. Test checkTeamLimit with users at different team counts (0, 1, 3, 10) and verify canCreate boolean is correct. Test with user who has no subscription record - should default to free tier limit of 1. Use React DevTools to inspect hook state and network tab to verify Supabase queries."
          },
          {
            "id": 5,
            "title": "Build subscription upgrade UI components and integrate team creation limit checks",
            "description": "Create subscription upgrade dialog component and modify team creation flow to check subscription limits before allowing team creation, with upgrade prompt when limit reached.",
            "dependencies": [
              3,
              4
            ],
            "details": "1) Create `components/settings/subscription-upgrade-dialog.tsx`: Dialog component with tier cards (free/standard/pro) displaying price, team limit, and features. Use loadStripe from @stripe/stripe-js. Upgrade button calls /api/stripe/checkout and redirects to Stripe. Use existing Dialog, Button, and UI components from components/ui/. 2) Create `components/settings/subscription-section.tsx`: Settings page section showing current subscription tier, team usage (X/Y teams), and upgrade button. 3) Modify `components/teams/team-form.tsx` (lines 66-122): In onSubmit handler, before team creation (line 86-98), add: `const limitCheck = await checkTeamLimit(user.id); if (!limitCheck.canCreate) { toast.error with limit message; show upgrade dialog; return; }`. Import useSubscriptionApi and add state for showing upgrade dialog. 4) Add subscription section to `app/settings/page.tsx`. Follow patterns from components/teams/team-form.tsx for form handling and components/settings/favorites-section.tsx for settings UI.",
            "status": "pending",
            "testStrategy": "Manual UI testing: 1) Test upgrade dialog displays correctly with all 3 tiers and pricing. Click Standard upgrade button, verify redirects to Stripe checkout. Complete test payment, verify redirects back to /settings?subscription=success. 2) Test team creation limit: Create teams until limit reached (use free tier = 1 team). On next attempt, verify error toast appears with message 'Team limit reached (1/1). Please upgrade your subscription.' and upgrade dialog opens. 3) Upgrade subscription via UI, verify can now create more teams. 4) Test settings page shows correct current tier and usage count. Use browser DevTools to verify API calls and network requests."
          }
        ]
      }
    ],
    "metadata": {
      "created": "2026-01-06T10:08:13.685Z",
      "description": "Default tasks context",
      "updated": "2026-01-06T10:10:17.338Z"
    }
  }
}